// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider  = "postgresql"
  url       = env("DATABASE_URL")
  directUrl = env("DIRECT_DATABASE_URL")
}

model User {
  id                    String    @id @default(cuid())
  worldcoinId           String?   @unique
  worldId               String?   @unique // World ID verification identifier
  walletAddress         String?   @unique
  nullifierHash         String?   @unique // World ID nullifier hash
  username              String    @unique
  displayName           String
  bio                   String?
  avatar                String?
  profilePictureUrl     String?
  isVerified            Boolean   @default(false)
  isPro                 Boolean   @default(false) // Pro subscription status
  isSeasonOneOG         Boolean   @default(false) // Season 1 OG Human badge
  isSuperAdmin          Boolean   @default(false) // Super admin privileges (can delete any tweet, upload community banners)
  verificationLevel     String?   // 'orb' or 'device'
  createdAt             DateTime  @default(now())
  updatedAt             DateTime  @updatedAt
  
  // Gamification fields
  currentRank           String    @default("HUMAN_VERIFIED") // HUMAN_VERIFIED, HUMAN_EXPLORER, HUMAN_PIONEER, HUMAN_ELITE, HUMAN_LEGEND, HUMAN_INFINITY
  rankScore             Int       @default(0)
  streakDays            Int       @default(0)
  lastStreakDate        DateTime? // Last date user posted (for streak tracking)
  longestStreak         Int       @default(0) // Longest streak achieved
  lastActiveAt          DateTime?
  contributionScore     Int       @default(0)
  engagementScore       Int       @default(0)
  invitesCount          Int       @default(0)
  successfulInvitesCount Int      @default(0)
  totalEarnings         Float     @default(0.0) // For Top Earners leaderboard
  country               String?
  city                  String?
  language              String?   @default("en")

  // Relations
  tweets                Tweet[]
  likes                 Like[]
  retweets              Retweet[]
  followers             Follow[] @relation("UserFollowers")
  following             Follow[] @relation("UserFollowing")
  comments              Comment[]
  tags                  UserTag[]
  infinityVotesReceived HumanInfinityVote[] @relation("InfinityVotesReceived")
  infinityVotesGiven    HumanInfinityVote[] @relation("InfinityVotesGiven")
  invitedBy             User?     @relation("UserInvites", fields: [invitedById], references: [id])
  invitedById           String?
  invitedUsers          User[]    @relation("UserInvites")
  leaderboardEntries    LeaderboardEntry[]
  communityMemberships  CommunityMember[]
  communityPosts        CommunityPost[]
  communityPostComments CommunityPostComment[]
  subscription          Subscription?

  @@map("users")
}

model Tweet {
  id                    String    @id @default(cuid())
  content               String
  authorId              String
  createdAt             DateTime  @default(now())
  updatedAt             DateTime  @updatedAt

  // Relations
  author                User      @relation(fields: [authorId], references: [id], onDelete: Cascade)
  likes                 Like[]
  retweets              Retweet[]
  media                 Media[]
  comments              Comment[]

  @@index([authorId])
  @@index([createdAt])
  @@map("tweets")
}

model Like {
  id                    String    @id @default(cuid())
  userId                String
  tweetId               String
  createdAt             DateTime  @default(now())

  // Relations
  user                  User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  tweet                 Tweet     @relation(fields: [tweetId], references: [id], onDelete: Cascade)

  @@unique([userId, tweetId])
  @@index([tweetId])
  @@index([userId])
  @@map("likes")
}

model Retweet {
  id                    String    @id @default(cuid())
  userId                String
  tweetId               String
  createdAt             DateTime  @default(now())

  // Relations
  user                  User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  tweet                 Tweet     @relation(fields: [tweetId], references: [id], onDelete: Cascade)

  @@unique([userId, tweetId])
  @@index([tweetId])
  @@index([userId])
  @@map("retweets")
}

model Follow {
  id                    String    @id @default(cuid())
  followerId            String
  followingId           String
  createdAt             DateTime  @default(now())

  // Relations
  follower              User      @relation("UserFollowing", fields: [followerId], references: [id], onDelete: Cascade)
  following             User      @relation("UserFollowers", fields: [followingId], references: [id], onDelete: Cascade)

  @@unique([followerId, followingId])
  @@map("follows")
}

model Media {
  id                    String    @id @default(cuid())
  tweetId               String
  type                  String    // 'image' or 'video'
  url                   String
  thumbnailUrl          String?
  alt                   String?
  createdAt             DateTime  @default(now())

  // Relations
  tweet                 Tweet     @relation(fields: [tweetId], references: [id], onDelete: Cascade)

  @@map("media")
}

model Comment {
  id                    String    @id @default(cuid())
  content               String
  authorId              String
  tweetId               String
  createdAt             DateTime  @default(now())
  updatedAt             DateTime  @updatedAt

  // Relations
  author                User      @relation(fields: [authorId], references: [id], onDelete: Cascade)
  tweet                 Tweet     @relation(fields: [tweetId], references: [id], onDelete: Cascade)

  @@index([tweetId])
  @@index([authorId])
  @@index([createdAt])
  @@map("comments")
}

// Gamification Models

model Season {
  id                    String    @id @default(cuid())
  name                  String    @unique
  theme                 String
  startAt               DateTime
  endAt                 DateTime
  isActive              Boolean   @default(false)
  createdAt             DateTime  @default(now())
  updatedAt             DateTime  @updatedAt

  // Relations
  tags                  Tag[]

  @@map("seasons")
}

model Tag {
  id                    String    @id @default(cuid())
  name                  String    @unique
  description           String?
  seasonId              String?
  isLimited             Boolean   @default(false)
  maxSupply             Int?      // null means unlimited
  currentSupply         Int       @default(0)
  metadata              String?   // JSON string for additional data
  createdAt             DateTime  @default(now())
  updatedAt             DateTime  @updatedAt

  // Relations
  season                Season?   @relation(fields: [seasonId], references: [id])
  userTags              UserTag[]

  @@map("tags")
}

model UserTag {
  id                    String    @id @default(cuid())
  userId                String
  tagId                 String
  grantedAt             DateTime  @default(now())
  reason                String?

  // Relations
  user                  User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  tag                   Tag       @relation(fields: [tagId], references: [id], onDelete: Cascade)

  @@unique([userId, tagId])
  @@map("user_tags")
}

model HumanInfinityVote {
  id                    String    @id @default(cuid())
  voterId               String    // User who gives the vote
  candidateId           String    // User who receives the vote
  reason                String?
  createdAt             DateTime  @default(now())

  // Relations
  voter                 User      @relation("InfinityVotesGiven", fields: [voterId], references: [id], onDelete: Cascade)
  candidate             User      @relation("InfinityVotesReceived", fields: [candidateId], references: [id], onDelete: Cascade)

  @@unique([voterId, candidateId])
  @@map("human_infinity_votes")
}

model LeaderboardSnapshot {
  id                    String    @id @default(cuid())
  type                  String    // GLOBAL_TOP_HUMANS, GLOBAL_TOP_CREATORS, REGIONAL_TOP_CREATORS, etc.
  periodStart           DateTime
  periodEnd             DateTime
  region                String?   // country, city, language, or community identifier
  regionType            String?   // 'country', 'city', 'language', 'community'
  createdAt             DateTime  @default(now())

  // Relations
  entries               LeaderboardEntry[]

  @@index([type, periodEnd])
  @@index([type, region, periodEnd])
  @@map("leaderboard_snapshots")
}

model LeaderboardEntry {
  id                    String    @id @default(cuid())
  snapshotId            String
  userId                String
  rankPosition          Int
  score                 Float
  metadata              String?   // JSON string for score breakdown
  createdAt             DateTime  @default(now())

  // Relations
  snapshot              LeaderboardSnapshot @relation(fields: [snapshotId], references: [id], onDelete: Cascade)
  user                  User      @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([snapshotId, userId])
  @@index([snapshotId, rankPosition])
  @@map("leaderboard_entries")
}

model Community {
  id                    String    @id @default(cuid())
  name                  String    @unique
  description           String
  category              String
  iconGradient          String    // e.g. "from-blue-500 to-cyan-500"
  iconName              String    // e.g. "Bot", "Globe"
  bannerUrl             String?   // Community banner image (super admin only)
  logoUrl               String?   // Community logo/profile picture (super admin only)
  memberCount           Int       @default(0)
  createdAt             DateTime  @default(now())
  updatedAt             DateTime  @updatedAt

  // Relations
  members               CommunityMember[]
  posts                 CommunityPost[]

  @@map("communities")
}

model CommunityMember {
  id                    String    @id @default(cuid())
  userId                String
  communityId           String
  joinedAt              DateTime  @default(now())

  // Relations
  user                  User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  community             Community @relation(fields: [communityId], references: [id], onDelete: Cascade)

  @@unique([userId, communityId])
  @@map("community_members")
}

model CommunityPost {
  id                    String    @id @default(cuid())
  content               String
  authorId              String
  communityId           String
  createdAt             DateTime  @default(now())
  updatedAt             DateTime  @updatedAt

  // Relations
  author                User      @relation(fields: [authorId], references: [id], onDelete: Cascade)
  community             Community @relation(fields: [communityId], references: [id], onDelete: Cascade)
  comments              CommunityPostComment[]

  @@map("community_posts")
}

model CommunityPostComment {
  id                    String    @id @default(cuid())
  content               String
  authorId              String
  postId                String
  createdAt             DateTime  @default(now())
  updatedAt             DateTime  @updatedAt

  // Relations
  author                User              @relation(fields: [authorId], references: [id], onDelete: Cascade)
  post                  CommunityPost     @relation(fields: [postId], references: [id], onDelete: Cascade)

  @@map("community_post_comments")
}

model Subscription {
  id                    String    @id @default(cuid())
  userId                String    @unique
  plan                  String    // "free" or "pro"
  status                String    // "active", "cancelled", "expired"
  walletAddress         String?   // Wallet address used for payment
  worldPaymentId        String?   // World Pay transaction ID
  startDate             DateTime  @default(now())
  endDate               DateTime?
  autoRenew             Boolean   @default(true)
  createdAt             DateTime  @default(now())
  updatedAt             DateTime  @updatedAt

  // Relations
  user                  User      @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("subscriptions")
}

model PaymentIntent {
  id                    String    @id @default(cuid())
  reference             String    @unique // UUID without hyphens
  userId                String
  amount                Float
  description           String
  status                String    @default("pending") // "pending", "success", "failed", "cancelled"
  transactionId         String?   // Worldcoin transaction ID after payment
  tokenUsed             String?   // "WLD" or "USDC"
  tokenAmount           String?   // Amount in tokens
  createdAt             DateTime  @default(now())
  updatedAt             DateTime  @updatedAt
  verifiedAt            DateTime? // When payment was verified on-chain

  @@map("payment_intents")
}
